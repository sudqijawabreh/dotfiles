#!/usr/bin/env bash

set -Eeuo pipefail

SESSIONS_ROOT="${CODEX_SESSIONS_ROOT:-$HOME/.codex/sessions}"
HISTORY_FILE="${CODEX_HISTORY_FILE:-$HOME/.codex/history.jsonl}"
LIMIT=25
ROLE="any"
SESSION_FILTER=""
TITLES_ONLY=0
FZF_MODE=0
PICK_ONLY=0

usage() {
  cat <<'USAGE'
Search Codex session history.

Usage:
  codex-history-search [options] <query>
  codex-history-search --fzf [seed-query]

Options:
  -n, --limit N        Max results (default: 25)
  -r, --role ROLE      any | user | assistant | developer (default: any)
  -s, --session ID     Filter to one session id
      --titles-only    Search sessions by title/cwd only
      --fzf            Pick query from Codex prompt history via fzf
      --pick-only      With --fzf, print selected query and exit
  -h, --help           Show help

Examples:
  codex-history-search "jira ticket"
  codex-history-search -n 10 -r user "state case sensitivity"
  codex-history-search --titles-only "hyprland"
  codex-history-search --fzf
USAGE
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Missing required command: $1" >&2
    exit 1
  fi
}

escape_sql_like() {
  local s="$1"
  s="${s//$'\t'/ }"
  s="${s//$'\n'/ }"
  s="${s//$'\r'/ }"
  printf '%s' "$s"
}

session_id_from_path() {
  local path="$1"
  local base
  base="$(basename "$path")"
  printf '%s\n' "$base" | grep -oE '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' | head -n 1 || true
}

pick_query_from_history() {
  local seed_query="$1"

  require_cmd fzf
  require_cmd jq

  if [[ ! -f "$HISTORY_FILE" ]]; then
    echo "Codex history not found: $HISTORY_FILE" >&2
    exit 1
  fi

  local selected
  selected="$({
    jq -r '.text // empty' "$HISTORY_FILE" \
      | awk 'NF' \
      | tac \
      | awk '!seen[$0]++'
  } | fzf \
      --prompt='Codex history> ' \
      --height=70% \
      --layout=reverse \
      --border \
      --query "$seed_query" \
      --preview 'echo {}' \
      --preview-window=down:3:wrap
  )"

  if [[ -z "$selected" ]]; then
    exit 130
  fi

  printf '%s\n' "$selected"
}

fallback_grep() {
  local query="$1"

  echo "Structured parse failed. Falling back to grep in Codex history/session files." >&2

  local paths=()
  [[ -f "$HISTORY_FILE" ]] && paths+=("$HISTORY_FILE")
  [[ -d "$SESSIONS_ROOT" ]] && paths+=("$SESSIONS_ROOT")

  if [[ ${#paths[@]} -eq 0 ]]; then
    echo "No Codex history sources found." >&2
    return 1
  fi

  rg -n --pretty -i --max-count "$LIMIT" -- "$query" "${paths[@]}"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -n|--limit)
      LIMIT="$2"
      shift 2
      ;;
    -r|--role)
      ROLE="$2"
      shift 2
      ;;
    -s|--session)
      SESSION_FILTER="$2"
      shift 2
      ;;
    --titles-only)
      TITLES_ONLY=1
      shift
      ;;
    --fzf)
      FZF_MODE=1
      shift
      ;;
    --pick-only)
      PICK_ONLY=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      exit 1
      ;;
    *)
      break
      ;;
  esac
done

if [[ "$FZF_MODE" -eq 1 ]]; then
  QUERY="$(pick_query_from_history "${*:-}")"
  if [[ "$PICK_ONLY" -eq 1 ]]; then
    printf '%s\n' "$QUERY"
    exit 0
  fi
else
  if [[ $# -eq 0 ]]; then
    usage
    exit 1
  fi
  QUERY="$*"
fi

if ! [[ "$LIMIT" =~ ^[0-9]+$ ]] || [[ "$LIMIT" -le 0 ]]; then
  echo "--limit must be a positive integer" >&2
  exit 1
fi

case "$ROLE" in
  any|user|assistant|developer) ;;
  *)
    echo "--role must be one of: any, user, assistant, developer" >&2
    exit 1
    ;;
esac

require_cmd jq
require_cmd rg
require_cmd awk

if [[ ! -d "$SESSIONS_ROOT" ]]; then
  echo "Codex sessions directory not found: $SESSIONS_ROOT" >&2
  exit 1
fi

tmpdir="$(mktemp -d)"
trap 'rm -rf "$tmpdir"' EXIT

titles_file="$tmpdir/titles.tsv"
sessions_file="$tmpdir/sessions.tsv"
messages_file="$tmpdir/messages.tsv"

if [[ -f "$HISTORY_FILE" ]]; then
  jq -r '[.session_id // "", (.text // "" | gsub("[\\r\\n\\t]+"; " "))] | @tsv' "$HISTORY_FILE" 2>/dev/null \
    | awk -F $'\t' 'NF >= 2 && $1 != "" && !seen[$1]++ { print $1 "\t" $2 }' > "$titles_file" || true
else
  : > "$titles_file"
fi

declare -A TITLE_BY_SESSION=()
while IFS=$'\t' read -r sid title; do
  [[ -n "$sid" ]] && TITLE_BY_SESSION["$sid"]="$title"
done < "$titles_file"

: > "$sessions_file"
while IFS= read -r file; do
  sid="$(session_id_from_path "$file")"
  [[ -z "$sid" ]] && continue

  cwd="$(jq -r 'select(.type=="session_meta") | .payload.cwd // empty' "$file" 2>/dev/null | head -n 1)"
  last_ts="$(jq -r '.timestamp // empty' "$file" 2>/dev/null | tail -n 1)"
  title="${TITLE_BY_SESSION[$sid]:-}"

  if [[ -z "$title" ]]; then
    title="$(jq -r '
      select(.type=="response_item" and .payload.type=="message" and .payload.role=="user") as $m
      | $m.payload.content[]?
      | (.text // .input_text // .output_text // empty)
      | select((.|type)=="string" and length > 0)
      | gsub("[\\r\\n\\t]+"; " ")
    ' "$file" 2>/dev/null | head -n 1)"
  fi

  printf '%s\t%s\t%s\t%s\t%s\n' "$last_ts" "$sid" "$cwd" "$title" "$file" >> "$sessions_file"
done < <(find "$SESSIONS_ROOT" -type f -name '*.jsonl' | sort)

sort -r "$sessions_file" -o "$sessions_file"

if [[ "$TITLES_ONLY" -eq 1 ]]; then
  if ! awk -F $'\t' -v q="$(printf '%s' "$QUERY" | tr '[:upper:]' '[:lower:]')" -v limit="$LIMIT" -v sidf="$SESSION_FILTER" '
    BEGIN {
      print "UPDATED                      SESSION                               CWD                                      TITLE"
      count = 0
    }
    {
      ts = $1
      sid = $2
      cwd = $3
      title = $4
      if (sidf != "" && sid != sidf) next
      hay = tolower(sid " " cwd " " title)
      if (index(hay, q) == 0) next
      if (length(cwd) > 40) cwd = substr(cwd, 1, 37) "..."
      if (length(title) > 80) title = substr(title, 1, 77) "..."
      printf "%-27s  %-36s  %-39s  %s\n", ts, sid, cwd, title
      count++
      if (count >= limit) exit
    }
  ' "$sessions_file"; then
    fallback_grep "$QUERY"
    exit $?
  fi
  exit 0
fi

: > "$messages_file"
while IFS=$'\t' read -r ts sid cwd title file; do
  [[ -z "$sid" || -z "$file" ]] && continue
  if [[ -n "$SESSION_FILTER" && "$sid" != "$SESSION_FILTER" ]]; then
    continue
  fi

  jq -r --arg sid "$sid" --arg cwd "$cwd" '
    select(.type=="response_item" and .payload.type=="message") as $m
    | ($m.payload.role // "unknown") as $role
    | ($m.timestamp // "") as $ts
    | $m.payload.content[]?
    | (.text // .input_text // .output_text // empty) as $txt
    | select(($txt|type)=="string" and ($txt|length)>0)
    | [
        $ts,
        $sid,
        $role,
        $cwd,
        ($txt | gsub("[\\r\\n\\t]+"; " "))
      ]
    | @tsv
  ' "$file" 2>/dev/null >> "$messages_file" || true
done < "$sessions_file"

if [[ ! -s "$messages_file" ]]; then
  fallback_grep "$QUERY"
  exit $?
fi

if ! awk -F $'\t' -v q="$(printf '%s' "$QUERY" | tr '[:upper:]' '[:lower:]')" -v rolef="$ROLE" -v limit="$LIMIT" -v sidf="$SESSION_FILTER" '
  NR == FNR {
    titles[$1] = $2
    next
  }
  BEGIN {
    print "TIME                         SESSION                               ROLE       TITLE                                        SNIPPET"
    count = 0
  }
  {
    ts = $1
    sid = $2
    role = $3
    text = $5
    title = titles[sid]

    if (sidf != "" && sid != sidf) next
    if (rolef == "any") {
      if (role != "user" && role != "assistant") next
    } else if (role != rolef) {
      next
    }

    hay = tolower(text " " title " " sid)
    if (index(hay, q) == 0) next

    title_out = title
    snippet = text
    if (length(title_out) > 44) title_out = substr(title_out, 1, 41) "..."
    if (length(snippet) > 150) snippet = substr(snippet, 1, 147) "..."

    printf "%-27s  %-36s  %-9s  %-44s  %s\n", ts, sid, role, title_out, snippet
    count++
    if (count >= limit) exit
  }
' "$titles_file" "$messages_file"; then
  fallback_grep "$QUERY"
  exit $?
fi
